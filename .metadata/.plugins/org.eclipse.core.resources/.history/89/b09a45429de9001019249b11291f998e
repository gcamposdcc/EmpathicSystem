package cl.automind.empathy.rule;

import interfaces.structural.INamed;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import util.ArrayUtils;
import cl.automind.empathy.data.AbstractDataManager;
import cl.automind.empathy.feedback.AbstractMessage;
import cl.automind.empathy.feedback.DefaultMessage;


/**
 * The base class for any empathic rule.
 * @author Guillermo
 */
public abstract class AbstractRule implements INamed{
	public static final int NON_EXECUTABLE = -1;
	
	private AbstractMessage message = new DefaultMessage();
	private final Map<String, Object> valuesMap = new HashMap<String, Object>();
	
	// <metadata-fields>
	private final String name;
	private final String[] strategies;
	private final double minValue;
	private final double maxValue;
	private final double threshold;
	private final double valueRange;
	private AbstractDataManager dataManager;
	// </metadata-fields>
	
	public AbstractRule(){
		RuleMetadata metadata = getClass().getAnnotation(RuleMetadata.class);
		// <metadata-fields-init>
		//TODO: Implement metadata corrections
		name = metadata != null ? metadata.name() : "";
		strategies = metadata != null ? metadata.strategies() : RuleMetadata.STRATEGIES;
		minValue = metadata != null ? metadata.minVal() : RuleMetadata.MIN_VALUE;
		maxValue = metadata != null ? metadata.maxVal() : RuleMetadata.MAX_VALUE;
		threshold = metadata != null ? metadata.threshold() : RuleMetadata.THRESHOLD;
		valueRange = maxValue - minValue;
		// </metadata-fields-init>
	}
	public AbstractRule(AbstractDataManager dataManager){
		this();
		setDataManager(dataManager);
	}
	
	// <metadata-fields-getters>
	@Override
	public String getName(){
		return name;
	}
	
	public String[] getStrategies(){
		return strategies;
	}
	protected double getMinValue(){
		return minValue;
	}
	protected double getMaxValue(){
		return maxValue;
	}
	protected double getThreshold(){
		return threshold;
	}
	protected double getValueRange(){
		return valueRange;
	}
	
	public boolean hasStrategy(String strategyName){
		if (strategyName.equals(StrategyMetadata.DEFAULT)) return true;
		return ArrayUtils.contains(getStrategies(), strategyName);
	}
	// </metadata-fields-getters>
	/**
	 * Determinates the priority of this rule.
	 * @return
	 */
	public abstract double evaluateImpl();
	public final double evaluate(Object... params){
		double val = normalize(evaluateImpl());
		return val >= normalize(getThreshold()) ? val : 0;
	}
	public abstract boolean canEvaluate(Object... params);

	protected final double normalize(double d){
		if (d < getMinValue()) return 0.0;
		if (d > getMaxValue()) return 1.0;
		return (d - getMinValue())/getValueRange();
	}
	
	public AbstractMessage getMessage(){
		return message;
	}
	public void setMessage(AbstractMessage message){
		this.message = message;
	}
	
	protected Object getValueByIdInSource(String dataSourceName, int id){
		return getDataManager().getValueById(dataSourceName, id);
	}
	protected <T> List<T> getAllInSource(String dataSourceName, T template){
		return getDataManager().getAll(dataSourceName, template);
	}
	protected int countAllInSource(String dataSourceName){
		return getDataManager().countElements(dataSourceName);
	}
	public void setDataManager(AbstractDataManager dataManager) {
		this.dataManager = dataManager;
	}

	public AbstractDataManager getDataManager() {
		return dataManager;
	}
	public Map<String, Object> getValuesMap() {
		return valuesMap;
	}
	public void clearValues(){
		getValuesMap().clear();
	}
	public void putValue(String key, Object value){
		getValuesMap().put(key, value);
	}
	public void removeValue(String key){
		getValuesMap().remove(key);
	}

}
